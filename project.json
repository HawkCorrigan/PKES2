{
  "Distance.cpp": "#include \"Distance.h\"\n#include <Arduino.h>\n#include <Frameiterator.h>\n#include <avr/io.h>\n#include <util/delay.h>\n\nuint8_t LookupShort [25] = \n{220,187,163,145,130,\n115,107,97,90,83,\n78,73,69,64,60,\n58,53,50,47,45,\n43,40,39,37,35};//3000 mV - 600 mV\n\nuint16_t LookupLong [18] =\n{630, 600, 500, 474, 447,\n420, 396, 372, 348, 324,\n300, 280, 260, 240, 220,\n200, 190, 175};//2700 mV - 1000 mV\n\n\n\nuint16_t ADC_mV_Faktor;\n\n/**\n * @brief Configures the ADC related to mode, clock speed, gain\n *        resolution and refrence voltage\n *\n *\n * chose the reference voltage carfully related to the output\n * range of the sensor.\n */\nvoid configADC()\n{\n  ADMUX |= _BV(REFS0);  // Vcc reference\n  ADCSRA |= _BV(ADEN);  // Enable\n}\n\n/**\n * @brief Starts a single conversion and receives a result return in mV\n */\nint16_t readADC(uint8_t channel)\n{\n\n  if (channel == 0)\n    ADMUX &= ~_BV(MUX0);\n  else\n    ADMUX |= _BV(MUX0);\n\n  ADCSRA |= _BV(ADSC); //trigger measurement\n  _delay_us(1);\n  \n  int16_t val = ADCL;\n  val |= ((uint16_t) ADCH << 8);\n  uint16_t mV = (float) val * 3.2258f;\n  return val;\n}\n\n/**\n * @brief Maps the digital voltage information on a distance\n *        in mm\n */\nuint16_t linearizeSR(uint16_t distmV) {\n  if(distmV<600) return 0;\n  if(distmV>3000) return 65000;\n  return LookupShort[(int)floor((distmV-600)/100)];\n}\n\n/**\n * @brief Maps the digital voltage information on a distance\n *        in mm\n */\n\n/**\n * @brief Better distance aproximation\n *        returns value in mm\n */",
  "Distance.h": "#ifndef ESSIRSENSOR_H\n#define ESSIRSENSOR_H\n\n#include <inttypes.h>\n\n\nvoid     configADC();\nuint16_t linearizeSR(uint16_t );\nuint16_t linearizeLR(uint16_t );\nint16_t readADC(uint8_t );\nuint16_t distance();\n\n\n#endif",
  "Ex4.ino": "\n// -----------------------------------------------------------------\n// Exercise 4\n// -----------------------------------------------------------------\n\n#include <FrameStream.h>\n#include <Frameiterator.h>\n#include <avr/io.h>\n#include \"Distance.h\"\n#include \"Odometry.h\"\n#include \"PID.h\"\n#include \"everytime.h\"\n#include \"MotorControl.h\"\n#include <math.h>\n\n\n\n\n\n\n\n#define OUTPUT__BAUD_RATE 57600\nFrameStream frm(Serial1);\n\n// Forward declarations\nvoid InitGUI();\n\n// hierarchical runnerlist, that connects the gui elements with\n// callback methods\ndeclarerunnerlist(GUI);\n\n// First level will be called by frm.run (if a frame is recived)\nbeginrunnerlist();\nfwdrunner(!g, GUIrunnerlist); //forward !g to the second level (GUI)\ncallrunner(!!, InitGUI);\nfwdrunner(ST, stickdata);\nendrunnerlist();\n\n// GUI level\nbeginrunnerlist(GUI);\ncallrunner(es, CallbackSTOP);\ncallrunner(ms, CallbackSTART);\nendrunnerlist();\n\n\nvoid stickdata(char* str, size_t length)\n{\n  int left = (int) atof(str);\n    int i; int right=0;\n    for(i=0; i<length; i++){\n      if (*(str+i)==','){\n        right=(int) atof(str+i+1);\n        break;\n      }\n    }\n  setMotors(left,right);\n}\n\nvoid CallbackSTOP()\n{\n    deactivateMotors();\n}\n\n\nvoid CallbackSTART()\n{\n    activateMotors();\n}\n\n\n\n\n/*\n * @brief initialises the GUI of ArduinoView\n *\n * In this function, the GUI, is configured. For this, Arduinoview shorthand,\n * HTML as well as embedded JavaScript can be used.\n */\nvoid InitGUI()\n{\n    delay(500);\n\n    frm.print(F(\"!SbesvSTOP\"));\n    frm.end();\n\n    frm.print(F(\"!SbmsvSTART\"));\n    frm.end();\n\n\n    //this implements a joystick field using HTML SVG and JS\n    //and some info divs next to it\n    frm.print(F(\"!H\"\n                \"<div><style>svg * { pointer-events: none; }</style>\\n\"\n                \"<div style='display:inline-block'> <div id='state'> </div>\\n\"\n                \"<svg id='stick' width='300' height='300' viewBox='-150 -150 300 300' style='background:rgb(200,200,255)' >\\n\"\n                \"<line id='pxy' x1='0' y1='0' x2='100' y2='100' style='stroke:rgb(255,0,0);stroke-width:3' />\\n\"\n                \"<circle id='cc' cx='0' cy='0' r='3'  style='stroke:rgb(0,0,0);stroke-width:3' />\\n\"\n                \"</svg></div>\"\n                \"<div style='display:inline-block'>\"\n                \"<div id='info0'></div>\"\n                \"<div id='info1'></div>\"\n                \"<div id='info2'></div>\"\n                \"</div></div>\\n\"\n                \"<script>\\n\"\n                \"var getEl=function(x){return document.getElementById(x)};\\n\"\n                \"var setEl=function(el,attr,val){(el).setAttributeNS(null,attr,val)};\\n\"\n                \"var stick=getEl('stick');\\n\"\n                \"function sticktransform(x,y){\\n\"\n                \"x = x-150;\\n\"\n                \"y = -(y-150);\\n\"\n                \"setstick(x,y);\\n\"\n                \"}\\n\"\n                \"function setstick(x,y){\\n\"\n                \"setpointer(x,y);\\n\"\n                \"l = Math.floor(Math.min(127,Math.max(-127,y + x/2)));\\n\"\n                \"r = Math.floor(Math.min(127,Math.max(-127,y - x/2)));\\n\"\n                \"setStateDisplay(x,y,l,r);\\n\"\n                \"sendframe(\\\"ST\\\"+l +\\\",\\\"+r);\\n\"\n                \"}\\n\"\n                \"function setStateDisplay(x,y,l,r){\\n\"\n                \"msg=getEl('state');\\n\"\n                \"msg.innerHTML= 'x= '+ x +' y= '+ y +' l= '+ l +' r= '+ r ;\\n\"\n                \"}\\n\"\n                \"function setpointer(x,y){\\n\"\n                \"pxy=getEl('pxy');\\n\"\n                \"setEl(pxy,'x2',x);\\n\"\n                \"setEl(pxy,'y2',-y);\\n\"\n                \"}\\n\"\n                \"stick.onmousemove=function(e){\\n\"\n                \"if( e.buttons == 1 ){\\n\"\n                \"sticktransform(e.offsetX,e.offsetY);\\n\"\n                \"}};\\n\"\n                \"stick.onmousedown=function(e){\\n\"\n                \"if( e.buttons == 1 ){\\n\"\n                \"sticktransform(e.offsetX,e.offsetY);\\n\"\n                \"}};\\n\"\n                \"stick.onmouseup=function(e){\\n\"\n                \"setstick(0,0);\\n\"\n                \"};\\n\"\n                \"stick.onmouseleave=function(e){\\n\"\n                \"setstick(0,0);\\n\"\n                \"};\\n\"\n                \"function sendframe(msg){\\n\"\n                \"ArduinoView.sendMessage(ArduinoView._createSerialFrame(msg))\\n\"\n                \"}\\n\"\n                \"setstick(0,0);\\n\"\n                \"</script>\\n\"));\n    frm.end();\n\n\n\n\n\n\n}\n\n/*\n * @brief Initialisation\n *\n * Implement basic initialisation of the program.\n */\n\n\nvoid setup()\n{\n    //prepare Serial interfaces\n    Serial.begin(OUTPUT__BAUD_RATE);\n    Serial1.begin(OUTPUT__BAUD_RATE);\n\n    Serial.println(F(\"Willkommen zur PKeS Ãœbung\"));\n\n    Serial.println(F(\"PKes4\"));\n\n    //request reset of GUI\n    frm.print(\"!!\");\n    frm.end();\n\n    delay(500);\n\n    // TODO initialize Odometry, Sensors, Motors, etc.\n  initOdom();\n  configADC();\n  //initSensors();\n  initMotors();\n  deactivateMotors();\n}\n\n/*\n *  @brief Main loop\n *\n *  This function will be called repeatedly and shall therefore implement the\n *  main behavior of the program.\n */\n\nvoid loop()\n{\n\n  every(50){\n    motorMain();\n      \n  }\n  every(75){\n    //VelocityData vD = getVelocityValues(0.5,0.5);\n    //setVelocityMotors(vD.left,vD.right);\n    //activateMotors();\n  }\n  \n    // read & run ArduinoView Frames\n    while(frm.run());\n}\n\n",
  "IMURegisters.h": "#pragma once\r\n\r\n#define IMU_SELF_TEST_X_GYR 0x00 /*0*/\r\n#define IMU_SELF_TEST_Y_GYR 0x01 /*1*/\r\n#define IMU_SELF_TEST_Z_GYR 0x02 /*2*/\r\n#define IMU_SELF_TEST_X_ACC 0x0D /*13*/\r\n#define IMU_SELF_TEST_Y_ACC 0x0E /*14*/\r\n#define IMU_SELF_TEST_Z_ACC 0x0F /*15*/\r\n#define IMU_XG_OFFSET_H 0x13 /*19*/\r\n#define IMU_XG_OFFSET_L 0x14 /*20*/\r\n#define IMU_YG_OFFSET_H 0x15 /*21*/\r\n#define IMU_YG_OFFSET_L 0x16 /*22*/\r\n#define IMU_ZG_OFFSET_H 0x17 /*23*/\r\n#define IMU_ZG_OFFSET_L 0x18 /*24*/\r\n#define IMU_SMPLRT_DIV 0x19 /*25*/\r\n#define IMU_CONFIG 0x1A /*26*/\r\n#define IMU_GYRO_CONFIG 0x1B /*27*/\r\n#define IMU_ACCEL_CONFIG 0x1C /*28*/\r\n#define IMU_ACCEL_CONFIG_2 0x1D /*29*/\r\n#define IMU_LP_ACCEL_ODR 0x1E /*30*/\r\n#define IMU_WOM_THR 0x1F /*31*/\r\n#define IMU_FIFO_EN 0x23 /*35*/\r\n#define IMU_I2C_MST_CTRL 0x24 /*36*/\r\n#define IMU_I2C_SLV0_ADDR 0x25 /*37*/\r\n#define IMU_I2C_SLV0_REG 0x26 /*38*/\r\n#define IMU_I2C_SLV0_CTRL 0x27 /*39*/\r\n#define IMU_I2C_SLV1_ADDR 0x28 /*40*/\r\n#define IMU_I2C_SLV1_REG 0x29 /*41*/\r\n#define IMU_I2C_SLV1_CTRL 0x2A /*42*/\r\n#define IMU_I2C_SLV2_ADDR 0x2B /*43*/\r\n#define IMU_I2C_SLV2_REG 0x2C /*44*/\r\n#define IMU_I2C_SLV2_CTRL 0x2D /*45*/\r\n#define IMU_I2C_SLV3_ADDR 0x2E /*46*/\r\n#define IMU_I2C_SLV3_REG 0x2F /*47*/\r\n#define IMU_I2C_SLV3_CTRL 0x30 /*48*/\r\n#define IMU_I2C_SLV4_ADDR 0x31 /*49*/\r\n#define IMU_I2C_SLV4_REG 0x32 /*50*/\r\n#define IMU_I2C_SLV4_DO 0x33 /*51*/\r\n#define IMU_I2C_SLV4_CTRL 0x34 /*52*/\r\n#define IMU_I2C_SLV4_DI 0x35 /*53*/\r\n#define IMU_I2C_MST_STATUS 0x36 /*54*/\r\n#define IMU_INT_PIN_CFG 0x37 /*55*/\r\n#define IMU_INT_ENABLE 0x38 /*56*/\r\n#define IMU_INT_STATUS 0x3A /*58*/\r\n#define IMU_ACCEL_XOUT_H 0x3B /*59*/\r\n#define IMU_ACCEL_XOUT_L 0x3C /*60*/\r\n#define IMU_ACCEL_YOUT_H 0x3D /*61*/\r\n#define IMU_ACCEL_YOUT_L 0x3E /*62*/\r\n#define IMU_ACCEL_ZOUT_H 0x3F /*63*/\r\n#define IMU_ACCEL_ZOUT_L 0x40 /*64*/\r\n#define IMU_TEMP_OUT_H 0x41 /*65*/\r\n#define IMU_TEMP_OUT_L 0x42 /*66*/\r\n#define IMU_GYRO_XOUT_H 0x43 /*67*/\r\n#define IMU_GYRO_XOUT_L 0x44 /*68*/\r\n#define IMU_GYRO_YOUT_H 0x45 /*69*/\r\n#define IMU_GYRO_YOUT_L 0x46 /*70*/\r\n#define IMU_GYRO_ZOUT_H 0x47 /*71*/\r\n#define IMU_GYRO_ZOUT_L 0x48 /*72*/\r\n#define IMU_EXT_SENS_DATA_00 0x49 /*73*/\r\n#define IMU_EXT_SENS_DATA_01 0x4A /*74*/\r\n#define IMU_EXT_SENS_DATA_02 0x4B /*75*/\r\n#define IMU_EXT_SENS_DATA_03 0x4C /*76*/\r\n#define IMU_EXT_SENS_DATA_04 0x4D /*77*/\r\n#define IMU_EXT_SENS_DATA_05 0x4E /*78*/\r\n#define IMU_EXT_SENS_DATA_06 0x4F /*79*/\r\n#define IMU_EXT_SENS_DATA_07 0x50 /*80*/\r\n#define IMU_EXT_SENS_DATA_08 0x51 /*81*/\r\n#define IMU_EXT_SENS_DATA_09 0x52 /*82*/\r\n#define IMU_EXT_SENS_DATA_10 0x53 /*83*/\r\n#define IMU_EXT_SENS_DATA_11 0x54 /*84*/\r\n#define IMU_EXT_SENS_DATA_12 0x55 /*85*/\r\n#define IMU_EXT_SENS_DATA_13 0x56 /*86*/\r\n#define IMU_EXT_SENS_DATA_14 0x57 /*87*/\r\n#define IMU_EXT_SENS_DATA_15 0x58 /*88*/\r\n#define IMU_EXT_SENS_DATA_16 0x59 /*89*/\r\n#define IMU_EXT_SENS_DATA_17 0x5A /*90*/\r\n#define IMU_EXT_SENS_DATA_18 0x5B /*91*/\r\n#define IMU_EXT_SENS_DATA_19 0x5C /*92*/\r\n#define IMU_EXT_SENS_DATA_20 0x5D /*93*/\r\n#define IMU_EXT_SENS_DATA_21 0x5E /*94*/\r\n#define IMU_EXT_SENS_DATA_22 0x5F /*95*/\r\n#define IMU_EXT_SENS_DATA_23 0x60 /*96*/\r\n#define IMU_I2C_SLV0_DO 0x63 /*99*/\r\n#define IMU_I2C_SLV1_DO 0x64 /*100*/\r\n#define IMU_I2C_SLV2_DO 0x65 /*101*/\r\n#define IMU_I2C_SLV3_DO 0x66 /*102*/\r\n#define IMU_I2C_MST_DELAY_CTRL 0x67 /*103*/\r\n#define IMU_SIGNAL_PATH_RESET 0x68 /*104*/\r\n#define IMU_MOT_DETECT_CTRL 0x69 /*105*/\r\n#define IMU_USER_CTRL 0x6A /*106*/\r\n#define IMU_PWR_MGMT_1 0x6B /*107*/\r\n#define IMU_PWR_MGMT_2 0x6C /*108*/\r\n#define IMU_FIFO_COUNTH 0x72 /*114*/\r\n#define IMU_FIFO_COUNTL 0x73 /*115*/\r\n#define IMU_FIFO_R_W 0x74 /*116*/\r\n#define IMU_WHO_AM_I 0x75 /*117*/\r\n#define IMU_XA_OFFSET_H 0x77 /*119*/\r\n#define IMU_XA_OFFSET_L 0x78 /*120*/\r\n#define IMU_YA_OFFSET_H 0x7A /*122*/\r\n#define IMU_YA_OFFSET_L 0x7B /*123*/\r\n#define IMU_ZA_OFFSET_H 0x7D /*125*/\r\n#define IMU_ZA_OFFSET_L 0x7E /*126*/",
  "MotorControl.cpp": "#include \"MotorControl.h\"\n#include <FrameStream.h>\n#include <Frameiterator.h>\n#include <avr/io.h>\n\n/* Function forward declaration*/\nvoid deactivateMotors();\nvoid activateMotors();\n/* Global vars */\n\n/* Functions */\n\nvoid initMotors(){\n  TCCR4D &= ~_BV(WGM41);\n  TCCR4D &= ~_BV(WGM40);\n  \n  TCCR4B |= _BV(CS40);\t\t// Prescaler x1\n  TCCR4B &= ~_BV(CS41);\n  TCCR4B &= ~_BV(CS42);\n  TCCR4B &= ~_BV(CS43);\n  \n  TCCR4A &= ~_BV(COM4B1);   // Set phase correct timer M2\n  TCCR4A |= _BV(COM4B0);\t\n  TCCR4A |= _BV(PWM4B);\t\t// Enable\n  TCCR4C &= ~_BV(COM4D1);   // Set phase correct timer M1\n  TCCR4C |= _BV(COM4D0);\n  TCCR4C |= _BV(PWM4D);\t\t// Enable\n}\n\nvoid setMotors(int8_t left, int8_t right){\n  OCR4B = 127+(left * -1);\n  OCR4D = 127+right;\n}\n\nvoid setVelocityMotors(float left, float right){\n   setMotors(left*127/0.6, right*127/0.6);\n}\n\nvoid deactivateMotors() {\n  // set input mode\n  DDRB &= ~_BV(PB5);\n  DDRB &= ~_BV(PB6);\n  DDRD &= ~_BV(PD6);\n  DDRD &= ~_BV(PD7);\n}\n\nvoid activateMotors() {\n  // set output mode\n  DDRB |= _BV(PB5);\n  DDRB |= _BV(PB6);\n  DDRD |= _BV(PD6);\n  DDRD |= _BV(PD7);\n}",
  "MotorControl.h": "#pragma once\n\n#include <inttypes.h>\n\nvoid initMotors();\nvoid setMotors(int8_t left, int8_t right);\nvoid updateMotors();\n\n// set the Velocity of both motor in m/s\nvoid setVelocityMotors(float left, float right);\n\n// these functions start and stop the automatic motor activation\nvoid activateMotors();\nvoid deactivateMotors();",
  "Odometry.cpp": "#include \"Odometry.h\"\n#include \"Distance.h\"\n#include <avr/interrupt.h>\n\nvolatile bool stateA=((PINB>>PB3)&1);\nvolatile bool stateB=((PINB>>PB4)&1);\n\nvolatile int32_t templeft=0;\nvolatile int32_t tempright=0;\nOdomData odomData = {.left=0,.right=0};\n\nvoid initOdom(){\n  \nDDRB &= ~(1<<PB0); //Odometry to input\nDDRB &= ~(1<<PB3);\nDDRB &= ~(1<<PB4);\nDDRB &= ~(1<<PB7);\n\nPCMSK0  |=  (1<<PCINT3)// enable odometry Interrupts \n        | (1<<PCINT4); \nPCICR   |= (1<<PCIE0); //Pin Change Interrupts\n\nsei();\n\n};\n\nVelocityData getVelocityData(){\n    VelocityData velocityData;\n  cli();\n  velocityData.left=(float)templeft/2195/0.075;\n  velocityData.right=(float)tempright/2195/0.075;\n  templeft=0;\n  tempright=0;\n  sei();\n    return velocityData;            \n}\n\nISR(PCINT0_vect){\n\nif(stateB != ((PINB >> PB4)&1)){ //If Change in Motor A\n    stateB = !stateB;\n    //Both forward criteria:\n\nif(stateB == ((PINB >> PB7)&1))\n         tempright++;\nelse //backwards\n        tempright--;\n}\n// cf Bstate\nif(stateA != ((PINB >> PB3)&1)){\n    stateA = !stateA;\n\nif(stateA == ((PINB >> PB0)&1))\n         templeft++;\nelse \n    templeft--;\n}\n}",
  "Odometry.h": "#pragma once\n\n\n#include <avr/io.h>\n#include <avr/interrupt.h>\n\n#include <inttypes.h>\n\n//Arduino.h has some Pi\n#include <Arduino.h>\n\n\n\nstruct OdomData\n{\n    volatile int32_t left;\n    volatile int32_t right;\n};\n\nstruct VelocityData\n{\n    float left;\n    float right;\n};\n\n\n//initialises Odometrie\nvoid initOdom();\n\n//writes count courrent of ticks to structure\nvoid odomTicks(struct OdomData&);\n\nVelocityData getVelocityData();",
  "PID.cpp": "#include \"Odometry.h\"\nfloat P=0.75;\nfloat I=4.5;\nfloat D=0.02;\nfloat lastErrorRight=0;\nfloat lastErrorLeft=0;\nfloat diffError=0;\nfloat error=0;\nfloat sumOfErrorsRight=0;\nfloat sumOfErrorsLeft=0;\n\nVelocityData getVelocityValues(float targetVelocityL, float targetVelocityR){\n  VelocityData velocityData = getVelocityData();\n  VelocityData setValues;\n  error=targetVelocityR-velocityData.right;\n  sumOfErrorsRight+=error;\n  diffError=error-lastErrorRight;\n  lastErrorRight=error;\n  setValues.right=P*error+I*sumOfErrorsRight*0.075+D*diffError/0.075;\n  error=targetVelocityL-velocityData.left;\n  sumOfErrorsLeft+=error;\n  diffError=error-lastErrorLeft;\n    setValues.left=P*error+I*sumOfErrorsLeft*0.075+D*diffError/0.075;\n  \n  return setValues;\n  }\n    ",
  "PID.h": "#pragma once\n#include \"Odometry.h\"\nVelocityData getVelocityValues(float targetVelocityL, float targetVelocityR);",
  "everytime.h": "#ifndef EVERYTIMEH24b0433\r\n#define EVERYTIMEH24b0433\r\n/* Copyright (c) 2017, Karl Fessel, lib everytime, All rights reserved.*/\r\n\r\n// these macros run a command or block in regular intervals\r\n\r\n/**\r\n * these macros depend on unspecified but very common behavior of C, C++ and\r\n * the target architectur:\r\n * - integer overflow for subtraction and addition\r\n * - if the return type of the time function is bigger than the storage\r\n *   the lower bits schould be stored\r\n *   (this behavior is specified for values that fit into the storrage type\r\n *    but is unspecified for values that are bigger)\r\n */\r\n\r\n/* simple versions for easy reading:\r\n * #define every(X) static uint16_t before = 0; uint16_t now = millis();\\\r\n *               if((now - before >= X) && (before = now,1) )\r\n *\r\n *     static uint32_t before = 0;\r\n *     unsigned long now = millis();\r\n *     if (now - before > 1000){\r\n *     before = now;\r\n */\r\n\r\n\r\n//this make the variable names more unique by adding the current line number\r\n#define IDCAT3( A, B) A ## B\r\n#define IDCAT2( A, B) IDCAT3( A, B)\r\n#define IDCAT(X) IDCAT2(X, __LINE__)\r\n\r\n/**\r\n * these are gereric variants to create the mor specifc ones\r\n * X      is the time betwen two runs\r\n * START  is the time of the first start or -1 to wait for the first perion after time 0 (-1 saves memory and flash)\r\n * STARTO is the time of the first start with offset from first test (now) (0 to start now)\r\n * F      is the function that returns some kind of time\r\n *  e.g.: Arduinos millis() and micros()\r\n *  !! millis() do not include all milliseconds since its incremented in\r\n *  !!   256 / 250 kHz steps and are compensated every ~42 milliseconds by adding another millisecond !!\r\n *  !! micros() function itself takes more than a microsecond to execute !!\r\n * T      is the type of the storage variable the type should behave as said above\r\n *\r\n * everySTF(X, START, F, T)\r\n *  start with offset from time 0, -1 -> first intevall\r\n *\r\n * everyNTF(X, STARTO, F, T)\r\n *  start with offset from now\r\n */\r\n#ifndef ET_DRIFT\r\n// Dirft Mode\r\n// 1 : drift if miss\r\n//      e.g.: trigger every 5, miss at 10 execution, starts at 11 next trigger will be 16\r\n// 2 : never drift but may loose its function if execution takes to long\r\n//      e.g.: trigger every 5, miss at 10 and 15 -> double trigger\r\n// 3 : no drift until big miss then drift to now\r\n//      e.g.: trigger every 5, miss at 10 and 15 -> trigger once at 16 next trigger will be 21\r\n// 4 : try to stay in messure, if big miss advance in steps\r\n//      e.g.: trigger every 5, miss at 10 and 15 trigger once at 16 next trigger will be 20\r\n#define ET_DRIFT 3\r\n#endif\r\n\r\n#if ET_DRIFT == 1\r\n// 34 Byte for everySTF(X, -1, millis(), uint16_t )\r\n// drift if miss\r\n// non dynamic initialisation of static variable saves space in memory and flash 0 saves even more\r\n#define everySTF(X, START, F, T) \\\r\n            T IDCAT(now) = (F);\\\r\n            static T IDCAT(before) = ((START) < 0) ? 0 : (0 - (X) + (START));\\\r\n            if( (IDCAT(now) - IDCAT(before) >= (X)) \\\r\n             && ((IDCAT(before) = IDCAT(now)),1) )\r\n\r\n// start with offset from now\r\n#define everyNTF(X, STARTO, F, T) \\\r\n            T IDCAT(now) = (F);\\\r\n            static (T) IDCAT(before) = IDCAT(now) - (X) + (STARTO);\\\r\n            if( (IDCAT(now) - IDCAT(before) >= (X)) \\\r\n             && ((IDCAT(before) = IDCAT(now)),1) )\r\n\r\n#endif\r\n#if ET_DRIFT == 2\r\n// 38 Byte for everySTF(X, -1, millis(), uint16_t )\r\n// no drift but may lose its function if miss is to big\r\n// non dynamic initialisation of static variable saves space in memory and flash 0 saves even more\r\n#define everySTF(X, START, F, T) \\\r\n            T IDCAT(now) = F;\\\r\n            static T IDCAT(before) = (START < 0) ? 0 : (0 - X + START);\\\r\n            if( (IDCAT(now) - IDCAT(before) >= X) \\\r\n             && ((IDCAT(before) += X),1) )\r\n\r\n// start with offset from now\r\n#define everyNTF(X, STARTO, F, T) \\\r\n            T IDCAT(now) = F;\\\r\n            static T IDCAT(before) = IDCAT(now) - X + STARTO;\\\r\n            if( (IDCAT(now) - IDCAT(before) >= X) \\\r\n             && ((IDCAT(before) += X),1) )\r\n#endif\r\n#if ET_DRIFT == 3\r\n// 46 Byte for everySTF(X, -1, millis(), uint16_t )\r\n// drift when big miss (two intervals) else no drift\r\n// non dynamic initialisation of static variable saves space in memory and flash 0 saves even more\r\n#define everySTF(X, START, F, T) \\\r\n            T IDCAT(now) = F;\\\r\n            static T IDCAT(before) = (START < 0) ? 0 : (0 - X + START);\\\r\n            if( (IDCAT(now) - IDCAT(before) >= X) \\\r\n              && ((IDCAT(before) = (IDCAT(now) - IDCAT(before) > 2 * X)?IDCAT(now):IDCAT(before) + X),1) )\r\n\r\n// start with offset from now\r\n#define everyNTF(X, STARTO, F, T) \\\r\n            T IDCAT(now) = F;\\\r\n            static T IDCAT(before) = IDCAT(now) - X + STARTO;\\\r\n            if( (IDCAT(now) - IDCAT(before) >= X) \\\r\n             && ((IDCAT(before) = (IDCAT(now) - IDCAT(before) > 2 * X)?IDCAT(now):IDCAT(before) + X),1) )\r\n#endif\r\n#if ET_DRIFT == 4\r\n// 68 Bytes for everySTF(X, -1, millis(), uint16_t )\r\n// this uses lambda functions for the caluculation of the increment\r\n// lambda functions are part of c++11\r\n#define everySTF(X, START, F, T) \\\r\n            T IDCAT(now) = F;\\\r\n            static T IDCAT(before) = (START < 0) ? 0 : (0 - X + START);\\\r\n            T IDCAT(dist) = IDCAT(now) - IDCAT(before);\\\r\n            if( (IDCAT(dist) >= X) \\\r\n             && (IDCAT(before) += [&](){ T step = 0; do{ step += X; }while( (IDCAT(dist) > step + X) && (step + X > step) ); return step; }() ,1  ))\r\n\r\n// start with offset from now\r\n#define everyNTF(X, STARTO, F, T) \\\r\n            T IDCAT(now) = F;\\\r\n            static T IDCAT(before) = IDCAT(now) - X + STARTO;\\\r\n            T IDCAT(dist) = IDCAT(now) - IDCAT(before);\\\r\n            T IDCAT(step) = 0;\\\r\n            if( (IDCAT(dist) >= X) \\\r\n             && (IDCAT(before) += [&](){ T step = 0; do{ step += X; }while( (IDCAT(dist) > step + X) && (step + X > step) ); return step; }() ,1  ))\r\n#endif\r\n\r\n\r\n// execute every X milliseconds (8 bit)\r\n\r\n#define everyb(X)            everySTF(X, -1, millis(), uint8_t )\r\n\r\n#define everynowb(X)         everyNTF(X,  0, millis(), uint8_t )\r\n\r\n// execute every X milliseconds (16 bit)\r\n\r\n#define every(X)            everySTF(X, -1, millis(), uint16_t )\r\n\r\n#define everynow(X)         everyNTF(X,  0, millis(), uint16_t )\r\n\r\n// execute every X milliseconds (32 bit)\r\n\r\n#define everyl(X)            everySTF(X, -1, millis(), uint32_t )\r\n\r\n#define everynowl(X)         everyNTF(X,  0, millis(), uint32_t )\r\n\r\n\r\n// execute every X microseconds (16 bit)\r\n// !! loop cycle may be longer on most arduinos than the resolution of this !!\r\n// (30 microseconds with this just toggeling a LED using arduino method digitalWrite)\r\n\r\n#define everyu(X)            everySTF(X, -1, micros(), uint16_t )\r\n\r\n#define everynowu(X)         everyNTF(X,  0, micros(), uint16_t )\r\n\r\n// execute every X microseconds (32 bit)\r\n\r\n#define everyul(X)            everySTF(X, -1, micros(), uint32_t )\r\n\r\n#define everynowul(X)         everyNTF(X,  0, micros(), uint32_t )\r\n\r\n\r\n#endif",
  "WallFollow.cpp": "short state=0;\n\nvoid motorMain(){\n switch(state){\n     0:wait();\n     break;\n     1:driveForward();\n     break;\n     2:turnAround();\n     break;\n     3:moveBack();\n     break;\n}\n  \nvoid wait(){\n  \n}",
  "WallFollow.h": ""
}